'''
==============================================================================================================
This section contains code for the Ising Model - task 1 in the assignment
==============================================================================================================
'''
import numpy as np
import matplotlib.pyplot as plt

def calculate_agreement(population, row, col, external=0.0):
    '''
    This function should return the extent to which a cell agrees with its neighbours.
    Inputs: population (numpy array)
            row (int)
            col (int)
            external (float)
    Returns:
            change_in_agreement (float)
    '''

    n_rows, n_cols = population.shape
    agreement = external
    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        r, c = row + dr, col + dc
        if 0 <= r < n_rows and 0 <= c < n_cols:
            agreement += population[row, col] * population[r, c]
    return agreement


def ising_step(population, external=0.0, alpha=1.0):
    '''
    This function will perform a single update of the Ising model
    Inputs: population (numpy array)
            external (float) - optional - the magnitude of any external "pull" on opinion
    '''

    n_rows, n_cols = population.shape
    row = np.random.randint(0, n_rows)
    col = np.random.randint(0, n_cols)
    agreement = calculate_agreement(population, row, col, external)
    p_flip = np.exp(-agreement / alpha) if agreement > 0 else 1
    if np.random.random() < p_flip:
        population[row, col] *= -1


# Your code for task 1 goes here

def plot_ising(im, population):
    '''
    This function will display a plot of the Ising model
    '''
    new_im = np.array([[255 if val == -1 else 1 for val in rows] for rows in population]).astype(np.int8)
    im.set_data(new_im)
    # Pause to update the image
    plt.pause(0.1)


def test_ising():
    '''
    This function will test the calculate_agreement function in the Ising model
    '''


print("Testing ising model calculations")
population = -np.ones((3, 3))
assert (calculate_agreement(population, 1, 1) == 4), "Test 1"

population[1, 1] = 1.
assert (calculate_agreement(population, 1, 1) == -4), "Test 2"

population[0, 1] = 1.
assert (calculate_agreement(population, 1, 1) == -2), "Test 3"

population[1, 0] = 1.
assert (calculate_agreement(population, 1, 1) == 0), "Test 4"

population[2, 1] = 1.
assert (calculate_agreement(population, 1, 1) == 2), "Test 5"

population[1, 2] = 1.
assert (calculate_agreement(population, 1, 1) == 4), "Test 6"

"Testing external pull"
population = -np.ones((3, 3))
assert (calculate_agreement(population, 1, 1, 1) == 3), "Test 7"
assert (calculate_agreement(population, 1, 1, -1) == 5), "Test 8"
assert (calculate_agreement(population, 1, 1, 10) == -6), "Test 9"
assert (calculate_agreement(population, 1, 1, -10) == 14), "Test 10"

print("Tests passed")


def ising_main(external=0.0, alpha=1.0):
    size = (100, 100)
    population = np.random.choice([-1, 1], size=size)

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_axis_off()
    im = ax.imshow(population, cmap='RdPu_r', interpolation='none')
    plt.colorbar(im, ax=ax)

    for frame in range(100):
        for step in range(1000):
            ising_step(population, external)
        plot_ising(im, population)
        print('Step:', frame, end='\r')

    plt.show()


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Ising Model Simulation')
    parser.add_argument('-ising_model', action='store_true', help='Run the Ising model simulation')
    parser.add_argument('-external', type=float, default=0.0, help='The magnitude of any external "pull" on opinion')
    parser.add_argument('-alpha', type=float, default=1, help='The value of alpha')

    args = parser.parse_args()

    if args.ising_model:
        ising_main(args.external, args.alpha)
