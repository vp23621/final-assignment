import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import argparse
import random

class Node:
    def __init__(self, value, index):
        self.value = value  # 节点的初始意见值为随机
        self.index = index  # 节点的索引
        self.connections = []  # 节点的邻接列表

class Network:
    def __init__(self, size):
        self.nodes = [Node(np.random.rand(), i) for i in range(size)]
        self.size = size
        self.node_colors = [node.value for node in self.nodes]  # 初始化节点颜色

    def make_small_world_network(self, re_wire_prob=0.2, neighbor_range=2):
        # 创建规则的环形网络
        for node in self.nodes:
            node.connections = [(node.index + i) % self.size for i in range(-neighbor_range, neighbor_range + 1) if i != 0]

        # 重连机制增加小世界特性
        for node in self.nodes:
            for i in range(len(node.connections)):
                if random.random() < re_wire_prob:
                    new_connection = random.randint(0, self.size - 1)
                    while new_connection == node.index or new_connection in node.connections:
                        new_connection = random.randint(0, self.size - 1)
                    node.connections[i] = new_connection

    def update_node_colors(self):
        self.node_colors = [node.value for node in self.nodes]

    def mean_opinion(self):
        return np.mean([node.value for node in self.nodes])

def update_opinions(network, beta=0.5, threshold=0.5):
    node = random.choice(network.nodes)
    if node.connections:
        neighbor = random.choice(node.connections)
        neighbor_node = network.nodes[neighbor]
        if abs(node.value - neighbor_node.value) < threshold:
            node.value += beta * (neighbor_node.value - node.value)
            neighbor_node.value += beta * (node.value - neighbor_node.value)

def plot_network(network, ax, positions):
    ax.clear()
    norm = plt.Normalize(0, 1)  # 使用固定的归一化范围
    network.update_node_colors()  # 更新节点颜色
    node_sizes = [100 for node in network.nodes]
    scatter = ax.scatter(positions[:, 0], positions[:, 1], c=network.node_colors, cmap='viridis', edgecolor='k', norm=norm, s=node_sizes)
    for node in network.nodes:
        for neighbor in node.connections:
            ax.plot([positions[node.index, 0], positions[neighbor, 0]],
                    [positions[node.index, 1], positions[neighbor, 1]], color="black", linestyle='-')

    ax.set_aspect('equal')
    ax.axis('off')
    return scatter


def update(frame, network, beta, threshold, positions, ax, mean_opinions):
    update_opinions(network, beta, threshold)
    network.update_node_colors()  # 更新节点颜色
    scatter = plot_network(network, ax, positions)

    ax.set_title(f'Iteration: {frame + 1}')  # 更新标题为当前迭代次数

    # 记录每次迭代后的平均意见值
    mean_opinions.append(network.mean_opinion())

    return scatter


def main():
    parser = argparse.ArgumentParser(description='Run the Deffuant model on a small-world network.')
    parser.add_argument('-size', type=int, default=10, help='Number of nodes in the network')
    parser.add_argument('-beta', type=float, default=0.5, help='Convergence parameter')
    parser.add_argument('-threshold', type=float, default=0.5, help='Threshold for influence')
    parser.add_argument('-re_wire_prob', type=float, default=0.2,
                        help='Probability of rewiring in the small-world network')
    parser.add_argument('-steps', type=int, default=100, help='Number of steps to run the simulation')
    args = parser.parse_args()

    network = Network(size=args.size)
    network.make_small_world_network(re_wire_prob=args.re_wire_prob)

    positions = np.array(
        [(np.cos(2 * np.pi * i / args.size), np.sin(2 * np.pi * i / args.size)) for i in range(args.size)])

    fig, ax = plt.subplots()
    plt.colorbar(plot_network(network, ax, positions))  # 显示颜色条

    # 用于存储每次迭代后的平均意见值
    mean_opinions = []

    # 传递 mean_opinions 参数
    ani = FuncAnimation(fig, update, frames=np.arange(args.steps),
                        fargs=(network, args.beta, args.threshold, positions, ax, mean_opinions),
                        interval=10, repeat=False)

    plt.show()

    # 绘制 mean opinion 随着迭代次数的变化图
    plt.figure()
    plt.plot(mean_opinions)
    plt.xlabel("Iteration")
    plt.ylabel("Mean Opinion")
    plt.title("Mean Opinion Over Time")
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    main()


if __name__ == "__main__":
    main()
