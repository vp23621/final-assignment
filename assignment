import matplotlib.cm as cm

class Node:

	def __init__(self, value, number, connections=None):

		self.index = number
		self.connections = connections
		self.value = value

class Network: 

	def __init__(self, nodes=None):

        if nodes is None:
            self.nodes = []
        else:
            self.nodes = nodes 


    def get_mean_degree(self):
       # summing up the length of the connections list for each Node in self.nodes
       total_degree = sum(len(node.connections) for node in self.nodes)
       mean_degree = total_degree / len(self.nodes)
       return mean_degree

    def get_mean_clustering(self):
       clustering_coefficients = []

       for node in self.nodes:
          if len(node.connections) < 2:
             # There may has a node with less than two connections and its clustering coefficient is 0
             clustering_coefficients.append(0)
             continue

          # Calculates the number of possible links between neighbors.
          neighbors = [i for i, is_connected in enumerate(node.connections) if is_connected]
          possible_links = len(neighbors) * (len(neighbors) - 1) / 2
          actual_links = sum(1 for i in range(len(neighbors))
                             for j in range(i + 1, len(neighbors))
                             if self.nodes[neighbors[i]].connections[neighbors[j]])

          clustering_coefficients.append(actual_links / possible_links)

       mean_clustering = sum(clustering_coefficients) / len(self.nodes)
       return mean_clustering

    def get_mean_path_length(self):
       num_nodes = len(self.nodes)
       path_lengths = [[float('inf') if i != j else 0 for j in range(num_nodes)] for i in range(num_nodes)]

       # Set the distance for the direct connections.
       for node in self.nodes:
          for neighbor_index, connected in enumerate(node.connections):
             if connected:
                path_lengths[node.index][neighbor_index] = 1

       # Implement the Floyd-Warshall algorithm to calculate the shortest distances between all pairs of node
       for k in range(num_nodes):
          for i in range(num_nodes):
             for j in range(num_nodes):
                path_lengths[i][j] = min(path_lengths[i][j], path_lengths[i][k] + path_lengths[k][j])

       # Compute the mean path length.
       total_path_length = sum(
          sum(row[i] for i in range(num_nodes) if row[i] != float('inf')) for row in path_lengths)
       count_paths = sum(
          1 for row in path_lengths for i in range(num_nodes) if row[i] != float('inf') and i != row.index)

       mean_path_length = total_path_length / count_paths
       return mean_path_length




	def make_random_network(self, N, connection_probability=0.5):
		'''
		This function makes a *random* network of size N.
		Each node is connected to each other node with probability p
		'''

		self.nodes = []
		for node_number in range(N):
			value = np.random.random()
			connections = [0 for _ in range(N)]
			self.nodes.append(Node(value, node_number, connections))

		for (index, node) in enumerate(self.nodes):
			for neighbour_index in range(index+1, N):
				if np.random.random() < connection_probability:
					node.connections[neighbour_index] = 1
					self.nodes[neighbour_index].connections[index] = 1

	def make_ring_network(self, N, neighbour_range=1):
	if N == 0:
		return
	self.nodes = [Node(np.random.random(), i, [0] * N) for i in range(N)]
	for (index, node) in enumerate(self.nodes):
		for j in range(1, neighbour_range + 1):
			left = (index - j) % N
			right = (index + j) % N
			node.connections[left] = 1
			node.connections[right] = 1
			self.nodes[left].connections[index] = 1
			self.nodes[right].connections[index] = 1	
	

	def make_small_world_network(self, N, re_wire_prob=0.2):
	if N == 0:
		return
	self.make_ring_network(N, neighbour_range=2)
	for (index, node) in enumerate(self.nodes):
		for neighbour_index in range(N):
			if neighbour_index != index and node.connections[neighbour_index] == 0:
				if np.random.random() < re_wire_prob:
					rewire_to_index = np.random.randint(0, N)
					node.connections[rewire_to_index] = 1
					self.nodes[rewire_to_index].connections[index] = 1

	def plot(self):

		fig = plt.figure()
		ax = fig.add_subplot(111)
		ax.set_axis_off()

		num_nodes = len(self.nodes)
		network_radius = num_nodes * 10
		ax.set_xlim([-1.1*network_radius, 1.1*network_radius])
		ax.set_ylim([-1.1*network_radius, 1.1*network_radius])

		for (i, node) in enumerate(self.nodes):
			node_angle = i * 2 * np.pi / num_nodes
			node_x = network_radius * np.cos(node_angle)
			node_y = network_radius * np.sin(node_angle)

			circle = plt.Circle((node_x, node_y), 0.3*num_nodes, color=cm.hot(node.value))
			ax.add_patch(circle)

			for neighbour_index in range(i+1, num_nodes):
				if node.connections[neighbour_index]:
					neighbour_angle = neighbour_index * 2 * np.pi / num_nodes
					neighbour_x = network_radius * np.cos(neighbour_angle)
					neighbour_y = network_radius * np.sin(neighbour_angle)

					ax.plot((node_x, neighbour_x), (node_y, neighbour_y), color='black')

def test_networks():

	#Ring network
	nodes = []
	num_nodes = 10
	for node_number in range(num_nodes):
		connections = [0 for val in range(num_nodes)]
		connections[(node_number-1)%num_nodes] = 1
		connections[(node_number+1)%num_nodes] = 1
		new_node = Node(0, node_number, connections=connections)
		nodes.append(new_node)
	network = Network(nodes)

	print("Testing ring network")
	assert(network.get_mean_degree()==2), network.get_mean_degree()
	assert(network.get_clustering()==0), network.get_clustering()
	assert(network.get_path_length()==2.777777777777778), network.get_path_length()

	nodes = []
	num_nodes = 10
	for node_number in range(num_nodes):
		connections = [0 for val in range(num_nodes)]
		connections[(node_number+1)%num_nodes] = 1
		new_node = Node(0, node_number, connections=connections)
		nodes.append(new_node)
	network = Network(nodes)

	print("Testing one-sided network")
	assert(network.get_mean_degree()==1), network.get_mean_degree()
	assert(network.get_clustering()==0),  network.get_clustering()
	assert(network.get_path_length()==5), network.get_path_length()

	nodes = []
	num_nodes = 10
	for node_number in range(num_nodes):
		connections = [1 for val in range(num_nodes)]
		connections[node_number] = 0
		new_node = Node(0, node_number, connections=connections)
		nodes.append(new_node)
	network = Network(nodes)

	print("Testing fully connected network")
	assert(network.get_mean_degree()==num_nodes-1), network.get_mean_degree()
	assert(network.get_clustering()==1),  network.get_clustering()
	assert(network.get_path_length()==1), network.get_path_length()

	print("All tests passed")

'''
==============================================================================================================
This section contains code for the Ising Model - task 1 in the assignment
==============================================================================================================
'''

def calculate_agreement(population, row, col, external=0.0):
	'''
	This function should return the extent to which a cell agrees with its neighbours.
	Inputs: population (numpy array)
			row (int)
			col (int)
			external (float)
	Returns:
			change_in_agreement (float)
	'''

	#Your code for task 1 goes here

	return np.random.random() * population

def ising_step(population, external=0.0):
	'''
	This function will perform a single update of the Ising model
	Inputs: population (numpy array)
			external (float) - optional - the magnitude of any external "pull" on opinion
	'''
	
	n_rows, n_cols = population.shape
	row = np.random.randint(0, n_rows)
	col  = np.random.randint(0, n_cols)

	agreement = calculate_agreement(population, row, col, external=0.0)

	if agreement < 0:
		population[row, col] *= -1

	#Your code for task 1 goes here

def plot_ising(im, population):
	'''
	This function will display a plot of the Ising model
	'''

    new_im = np.array([[255 if val == -1 else 1 for val in rows] for rows in population], dtype=np.int8)
    im.set_data(new_im)
    plt.pause(0.1)

def test_ising():
	'''
	This function will test the calculate_agreement function in the Ising model
	'''

    print("Testing ising model calculations")
    population = -np.ones((3, 3))
    assert(calculate_agreement(population,1,1)==4), "Test 1"

    population[1, 1] = 1.
    assert(calculate_agreement(population,1,1)==-4), "Test 2"

    population[0, 1] = 1.
    assert(calculate_agreement(population,1,1)==-2), "Test 3"

    population[1, 0] = 1.
    assert(calculate_agreement(population,1,1)==0), "Test 4"

    population[2, 1] = 1.
    assert(calculate_agreement(population,1,1)==2), "Test 5"

    population[1, 2] = 1.
    assert(calculate_agreement(population,1,1)==4), "Test 6"

    "Testing external pull"
    population = -np.ones((3, 3))
    assert(calculate_agreement(population,1,1,1)==3), "Test 7"
    assert(calculate_agreement(population,1,1,-1)==5), "Test 8"
    assert(calculate_agreement(population,1,1,10)==-6), "Test 9"
    assert(calculate_agreement(population,1,1, -10)==14), "Test 10"

    print("Tests passed")


def ising_main(population, alpha=None, external=0.0):
    
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_axis_off()
    im = ax.imshow(population, interpolation='none', cmap='RdPu_r')

    # Iterating an update 100 times
    for frame in range(100):
        # Iterating single steps 1000 times to form an update
        for step in range(1000):
            ising_step(population, external)
        print('Step:', frame, end='\r')
        plot_ising(im, population)


'''
==============================================================================================================
This section contains code for the Defuant Model - task 2 in the assignment
==============================================================================================================
'''


'''
==============================================================================================================
This section contains code for the main function- you should write some code for handling flags here
==============================================================================================================
'''

def main():
	#You should write some code for handling flags here

if __name__=="__main__":
	main()import random
import argparse
import numpy as np
import matplotlib.pyplot as plt

def initilize(num_people):
    # Generate a ramdom opinion for each person
    return np.random.rand(num_people)

def update(opinion,beta, threshold,num_iterations):
    """
    This function update the opinion if it satisfies.

    beta(int)
    threshold(int)
    """
    # Create a list for the opinion value for each time iteration
    opinion_over_time = []
    for j in range(num_iterations):
        # Choose a random person
        i = np.random.randint(len(opinion))
        # Ensure all the neighbour is in bounds
        if i == 0:
            neighbour = i + 1
        elif i == (len(opinion) - 1):
            neighbour = i - 1
        else:
            # Select random neighbour except for the first and last one
            neighbour = (i+random.choice([-1,1]))
            # Calculate the difference of their opinion
        difference = opinion[i] - opinion[neighbour]

        if abs(difference) < threshold:

            # Update the opinion if they are eligible
            opinion[i] += (beta * (opinion[neighbour] - opinion[i]))
            opinion[neighbour] += (beta * (opinion[i] - opinion[neighbour]))
        #put all the opinion in a list
        opinion_over_time.append(opinion.copy())
    return opinion_over_time




def plot_opinion(opinion_over_time, num_iterations, beta, threshold):
    """
    This function takes four numbers as input and return the two graphs.
    (hist and the iteration for opinion)

    parameter:
    beta(int)
    num_iteration(int)
    threshold(int)
    """
    fig = plt.figure()
    ax1 = fig.add_subplot(1, 2, 1)
    # Generate a histogram
    ax1.hist(opinion_over_time[-1], bins=10)
    # Set x and y label
    ax1.set_xlabel('Opinion')
    ax1.set_ylabel('Number')
    # Set x_axis from 0 to 1
    x_ticks = np.arange(0, 1.1, 0.2)
    ax1.set_xticks(x_ticks)
    ax2 = fig.add_subplot(1, 2, 2)
    # Generate the second graph
    ax2.plot(range(num_iterations), opinion_over_time, 'ro')
    # Set x and y label
    ax2.set_ylabel('Opinion')
    ax2.set_xlabel('iteration')
    # Set the headline
    fig.suptitle(f'Coupling:{beta},Threshold:{threshold}')
    plt.tight_layout()
    plt.show()


def defuant_main(beta, threshold):
    num_people = 100
    num_iterations = 10000
    opinion_over_time = update(initilize(num_people), beta, threshold,num_iterations)
    plot_opinion(opinion_over_time, num_iterations, beta, threshold)



def test_defuant():
    defuant_main(0.5,0.5)
    defuant_main(0.1, 0.5)
    defuant_main(0.5, 0.1)
    defuant_main(0.1, 0.2)
def main():
    parser = argparse.ArgumentParser(description="Solve the defuant model")
    parser.add_argument("-beta", type=float, default=0.2,
                        help="Set the beta value here. Default: 0.2")
    parser.add_argument("-threshold", type=float, default=0.2,
                        help="Set the threshold value here. Default: 0.2")
    parser.add_argument("-defuant",
                        help="help run the defuant model.", action="store_true")
    parser.add_argument("-test_defuant",
                        help="help run the test model.", action="store_true")
    args = parser.parse_args()
    if args.defuant:
        defuant_main(args.beta, args.threshold)
    if args.test_defuant:
         test_defuant()


if __name__ == "__main__":
    main()


